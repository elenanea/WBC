# WBC1 Original Algorithm - Implementation Documentation

## Обзор

Реализация оригинального алгоритма WBC1 на основе описания из научной статьи.

### Ключевая концепция

Алгоритм основан на принципе кубика Рубика с побитовой обработкой ключа:

1. **Данные разбиваются на блоки** переменного размера s ∈ {32, 64, 128, 512} бит
2. **Каждый блок записывается в 3D куб** размером d×d×d
3. **Каждый бит ключа K выбирает одну из 127 операций** над кубом
4. **После каждой операции выполняется циклический побитовый сдвиг** на d бит
5. **Блоки обрабатываются параллельно** с использованием MPI

## Математическое описание

### 1. Разбиение текста

Текст T разбивается на k блоков:

```
T = {B₁, B₂, ..., Bₖ}
k = ⌈|T|/s⌉
```

где:
- `|T|` - длина текста в битах
- `s` - размер блока в битах (32, 64, 128 или 512)
- `Bᵢ` - i-й блок размером s бит

### 2. Организация в куб

Каждый блок Bᵢ записывается в 3D массив (куб) размером d×d×d:

| Размер блока s | Размер куба d×d×d | d |
|----------------|-------------------|---|
| 32 бита | 2×2×2 | 2 |
| 64 бита | 2×2×4 | 4 |
| 128 бит | 2×4×4 или 2×2×8 | 4 |
| 512 бит | 4×4×8 или 2×8×8 | 8 |

### 3. Таблица операций P

Создается таблица P из 127 операций перестановки:

```
P = {p₁, p₂, ..., p₁₂₇}
```

где каждая операция pᵢ - это преобразование куба (поворот граней, срезы, комбинации).

### 4. Алгоритм шифрования

Для каждого блока Bᵢ:

```
Вход: блок B размером s бит, ключ K длиной k бит

1. Записать B в куб d×d×d
2. Для j = 0 до k-1:
       a. key_bit = K[j]  // j-й бит ключа
       b. op_id = key_bit mod 127  // выбор операции
       c. B = P[op_id](B)  // применение операции
       d. B = циклический_сдвиг(B, d)  // сдвиг на d бит
3. Извлечь B из куба
4. Вернуть зашифрованный блок B'
```

### 5. Алгоритм дешифрования

Процесс выполняется в обратном порядке:

```
Вход: зашифрованный блок B', ключ K

1. Записать B' в куб
2. Для j = k-1 до 0 (в обратном порядке):
       a. B' = циклический_сдвиг⁻¹(B', d)  // обратный сдвиг
       b. key_bit = K[j]
       c. op_id = key_bit mod 127
       d. B' = P[op_id]⁻¹(B')  // обратная операция
3. Извлечь B' из куба
4. Вернуть расшифрованный блок B
```

## Реализация

### Структуры данных

```c
typedef struct {
    uint8_t *key;              // Ключ шифрования
    int key_len_bytes;         // Длина ключа в байтах
    int key_len_bits;          // Длина ключа в битах
    int block_size_bits;       // Размер блока (32, 64, 128, 512)
    int block_size_bytes;      // Размер блока в байтах
    int cube_d;                // Размерность куба d
    Operation *operations;     // Таблица из 127 операций
} WBC1OriginalCipher;
```

### Ключевые функции

#### Инициализация

```c
void wbc1_original_init(WBC1OriginalCipher *cipher, 
                        const uint8_t *key, 
                        int key_len, 
                        int block_size_bits);
```

Параметры:
- `key` - ключ шифрования
- `key_len` - длина ключа в байтах (16, 24 или 32 для 128, 192, 256 бит)
- `block_size_bits` - размер блока: 32, 64, 128 или 512

#### Шифрование блока

```c
void wbc1_original_encrypt_block(WBC1OriginalCipher *cipher,
                                 const uint8_t *plaintext,
                                 uint8_t *ciphertext);
```

Шифрует один блок размером `block_size_bytes`.

#### Дешифрование блока

```c
void wbc1_original_decrypt_block(WBC1OriginalCipher *cipher,
                                 const uint8_t *ciphertext,
                                 uint8_t *plaintext);
```

Расшифровывает один блок.

#### Параллельное шифрование (MPI)

```c
void parallel_original_encrypt(WBC1OriginalCipher *cipher,
                               const uint8_t *plaintext,
                               int plaintext_len,
                               uint8_t **ciphertext,
                               int *ciphertext_len);
```

Шифрует данные произвольной длины с использованием MPI для параллелизма.

#### Параллельное дешифрование (MPI)

```c
void parallel_original_decrypt(WBC1OriginalCipher *cipher,
                               const uint8_t *ciphertext,
                               int ciphertext_len,
                               uint8_t **plaintext,
                               int *plaintext_len);
```

## Компиляция и использование

### Компиляция

```bash
make original
```

Требования:
- MPI (Open MPI, MPICH или аналог)
- OpenSSL (для SHA-256)
- Компилятор C (gcc, clang)

### Запуск

#### Шифрование демо-текста (оригинальное поведение)

```bash
# 32-битные блоки (малый размер, быстрое шифрование)
mpirun -n 4 ./wbc1_original_parallel 0 256 0 32

# 64-битные блоки
mpirun -n 4 ./wbc1_original_parallel 0 256 0 64

# 128-битные блоки (совместимо с AES)
mpirun -n 4 ./wbc1_original_parallel 0 256 0 128

# 512-битные блоки (большие блоки для больших данных)
mpirun -n 4 ./wbc1_original_parallel 0 256 0 512
```

#### Шифрование данных произвольного размера

```bash
# Зашифровать 10 КБ случайных данных (128-битные блоки)
mpirun -n 4 ./wbc1_original_parallel 0 256 0 128 1 10

# Зашифровать 100 КБ данных
mpirun -n 4 ./wbc1_original_parallel 0 256 0 128 1 100

# Зашифровать 1 МБ данных (1000 КБ)
mpirun -n 4 ./wbc1_original_parallel 0 256 0 128 1 1000

# Зашифровать 10 МБ данных (максимум)
mpirun -n 4 ./wbc1_original_parallel 0 256 0 128 1 10000
```

#### Параметры командной строки

```
./wbc1_original_parallel <task> <key_size> <key_source> <block_size_bits> [mode] [data_size_kb]

task:            0 = шифрование/дешифрование текста
                 1 = статистические тесты
key_size:        128, 192 или 256 (размер ключа в битах)
key_source:      0 = случайный ключ, 1 = из файла
block_size_bits: 32, 64, 128 или 512 (размер блока в битах)
mode:            (для task 0) 0 = демо-текст, 1 = случайные данные
                 (для task 1) 0 = простой режим, 1 = полный режим
data_size_kb:    размер данных в КБ (1-10000)
                 - для task 0 с mode=1: размер генерируемых данных
                 - для task 1: размер данных для статистических тестов
```

#### Примеры использования

```bash
# 1. Шифрование демо-текста (оригинальное поведение)
mpirun -n 4 ./wbc1_original_parallel 0 256 0 128

# 2. Шифрование 10 КБ случайных данных
mpirun -n 4 ./wbc1_original_parallel 0 256 0 128 1 10

# 3. Шифрование 1 МБ данных для теста производительности
mpirun -n 4 ./wbc1_original_parallel 0 256 0 128 1 1000

# 4. Статистические тесты с 100 КБ данных
mpirun -n 4 ./wbc1_original_parallel 1 256 0 128 1 100
```

### Тестирование

```bash
make test-original
```

Выполняет два теста:
1. Шифрование с 32-битными блоками
2. Шифрование со 128-битными блоками

## Сравнение с другими версиями

| Характеристика | Оригинальная | Улучшенная (new) | Параметрическая (gen) |
|----------------|--------------|------------------|-----------------------|
| **Структура** | Один проход | 16 раундов | Один проход |
| **Обработка ключа** | Побитно | По байтам (32/раунд) | Побитно с PRF |
| **Операций за проход** | key_bits × 1 | 16 × 32 = 512 | key_bits × 1 |
| **Размер блока** | 32-512 бит | 128 бит | 128 бит |
| **Сложность** | O(k) | O(512) | O(k × PRF) |
| **Скорость** | ⚡⚡⚡⚡⚡ | ⚡⚡⚡ | ⚡⚡ |
| **Криптостойкость** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **S-box** | Нет | Да | Нет |
| **Диффузия** | Только сдвиг | Многослойная | Только сдвиг |
| **Гибкость блока** | Да (4 размера) | Нет (128 фикс.) | Нет (128 фикс.) |

где k - количество бит в ключе.

## Особенности реализации

### Преимущества

1. **Простота:** Минимальная структура, легко понять и реализовать
2. **Скорость:** Быстрее улучшенных версий (меньше операций)
3. **Гибкость блоков:** Поддержка 4 разных размеров блоков
4. **Малые блоки:** Эффективна для 32-64 битных блоков
5. **MPI масштабируемость:** Хорошо параллелизуется

### Ограничения

1. **Базовая криптостойкость:** Нет S-box, диффузии, раундовых ключей
2. **Простые операции:** Упрощенные перестановки (в данной реализации)
3. **Линейная структура:** Один проход вместо многораундовой структуры
4. **Анализ:** Проще для криптоанализа чем улучшенные версии

### Когда использовать

**Оригинальная версия подходит для:**
- Быстрого шифрования больших объемов данных
- Случаев, где скорость важнее максимальной криптостойкости
- Встраиваемых систем с ограниченными ресурсами
- Малых размеров блоков (32-64 бита)
- Изучения базовых принципов алгоритма

**Используйте улучшенные версии для:**
- Максимальной криптостойкости
- Совместимости с AES (128-битные блоки)
- Защиты критически важных данных

## Пример вывода

```
========================================
WBC1 Original Algorithm - Text Encryption Demo
========================================
Block size: 128 bits (16 bytes)
Key size: 256 bits
Cube dimension: 4×4×4
Key bits processed: 256

Original text: Це тестове повідомлення для демонстрації...

Encrypted (80 bytes):
a3f1b9e4c7d2a5b8...

Decrypted text: Це тестове повідомлення для демонстрації...

Encryption time: 0.002341 seconds
Decryption time: 0.002198 seconds
✓ Success: Decrypted text matches original!
```

## Техническая информация

### Циклический побитовый сдвиг

Реализован на уровне отдельных бит:

```c
static void cyclic_bitwise_shift(uint8_t *block, int size_bytes, int shift_bits);
```

Выполняет циклическую ротацию всех бит блока на `shift_bits` позиций.

### Извлечение бита ключа

```c
static int get_key_bit(const uint8_t *key, int bit_index, int key_len_bytes);
```

Извлекает бит из ключа (MSB first, с циклическим повтором при необходимости).

### MPI распределение

Блоки распределяются между процессами с использованием `MPI_Scatterv`/`MPI_Gatherv` для балансировки нагрузки.

## Заключение

Оригинальная версия WBC1 представляет собой простую, но эффективную реализацию алгоритма шифрования на основе кубика Рубика. Она демонстрирует основные принципы алгоритма и может быть использована для быстрого шифрования или в качестве базы для более сложных вариантов.

Для максимальной криптостойкости рекомендуется использовать улучшенные версии (wbc1_parallel_new.c) или параметрическую версию (wbc1_parallel_gen_cached.c).
