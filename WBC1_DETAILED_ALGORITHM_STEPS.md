# Детальное пошаговое описание алгоритма WBC1

## Полный анализ всех реализаций с подробным объяснением каждого шага

---

## СОДЕРЖАНИЕ

1. [Введение и общая архитектура](#1-введение-и-общая-архитектура)
2. [Оригинальный алгоритм - подробные шаги](#2-оригинальный-алгоритм---подробные-шаги)
3. [Улучшенный алгоритм - подробные шаги](#3-улучшенный-алгоритм---подробные-шаги)
4. [Параметрический алгоритм - подробные шаги](#4-параметрический-алгоритм---подробные-шаги)
5. [Конкретный пример шифрования](#5-конкретный-пример-шифрования)
6. [Структуры данных и реализация](#6-структуры-данных-и-реализация)
7. [Файлы проекта и их назначение](#7-файлы-проекта-и-их-назначение)

---

## 1. ВВЕДЕНИЕ И ОБЩАЯ АРХИТЕКТУРА

### 1.1. Что такое WBC1?

**WBC1 (White-Box Cipher 1)** — это блочный симметричный шифр, основанный на концепции **куба Рубика**.

**Основная идея:**
- Данные организуются в 3D структуру (куб)
- Применяются операции поворотов, аналогичные кубу Рубика
- Каждая операция перемешивает данные внутри куба
- Ключ определяет последовательность операций

### 1.2. Версии алгоритма

В проекте реализовано **9 версий** алгоритма WBC1:

| Файл | Описание | Особенности |
|------|----------|-------------|
| **wbc1_original_parallel.c** | Оригинальная версия | Побитовая обработка ключа, 256 итераций на блок |
| **wbc1_original_cached.c** | Оригинальная с кешированием | То же + предвычисления для ускорения |
| **wbc1_parallel_new.c** | Улучшенная версия | Раундовая структура, S-box, диффузия |
| **wbc1_parallel_cached_new.c** | Улучшенная с кешированием | То же + предвычисления |
| **wbc1_parallel_cached_opti.c** | Оптимизированная | Максимальная оптимизация кешаи |
| **wbc1_parallel_gen_cached.c** | Параметрическая | Генерация операций через PRF |
| **wbc1_parallel_minimal.c** | Минимальная | Упрощенная для понимания |
| **wbc1_parallel.c** | Базовая | Исходная реализация |
| **wbc1_parallel_cached.c** | Базовая с кешем | Базовая + кеш |

### 1.3. Ключевые концепции

**Блочное шифрование:**
- Данные разбиваются на блоки фиксированного размера
- Каждый блок шифруется независимо
- Размер блока: обычно 16 байт (128 бит)

**3D куб:**
- Блок представляется как куб размером d₁ × d₂ × d₃
- Для 16 байт: куб 2×2×4
- Каждая ячейка куба содержит 1 байт данных

**Операции перестановки:**
- Всего 127 различных операций
- Каждая операция — это перестановка байтов в кубе
- Операции аналогичны поворотам куба Рубика

---

## 2. ОРИГИНАЛЬНЫЙ АЛГОРИТМ - ПОДРОБНЫЕ ШАГИ

### Файлы: wbc1_original_parallel.c, wbc1_original_cached.c

### 2.1. ОБЩАЯ СХЕМА

```
Входные данные → Разбиение на блоки → Для каждого блока:
                                           ├─ Побитовая обработка ключа
                                           ├─ 256 итераций
                                           ├─ Выбор операции
                                           ├─ Применение операции
                                           ├─ Циклический сдвиг
                                           └─ Следующая итерация
                 → Объединение блоков → Зашифрованные данные
```

### 2.2. ШАГ 1: ИНИЦИАЛИЗАЦИЯ

**Что происходит:**
1. Генерируется ключ заданного размера (128, 192 или 256 бит)
2. Создается таблица из 127 операций перестановки
3. Определяются размеры куба

**Код:**
```c
// Инициализация структуры шифра
WBC1OriginalCipher cipher;
wbc1_original_init(&cipher, key, key_size, block_size_bits);

// Внутри:
// 1. Копируется ключ
memcpy(cipher->key, key, key_len);

// 2. Вычисляются размеры куба
// Для 32-bit блока (4 байта): куб 2×2×2
// Для 64-bit блока (8 байт): куб 2×2×4
// Для 128-bit блока (16 байт): куб 2×4×4
// Для 512-bit блока (64 байта): куб 4×4×8

// 3. Генерируется таблица операций
// 127 различных перестановок байтов
```

**Детали:**
- Таблица операций фиксирована и основана на операциях куба Рубика
- Каждая операция — это биекция (взаимно-однозначное отображение)
- Операции обратимы (есть обратная операция)

### 2.3. ШАГ 2: РАЗБИЕНИЕ ДАННЫХ НА БЛОКИ

**Что происходит:**
Входной текст разбивается на блоки фиксированного размера.

**Пример:**
```
Текст: "Hello, World! This is a test message"
Размер блока: 4 байта (32 бита)

Блоки:
Блок 0: "Hell" = [0x48, 0x65, 0x6C, 0x6C]
Блок 1: "o, W" = [0x6F, 0x2C, 0x20, 0x57]
Блок 2: "orld" = [0x6F, 0x72, 0x6C, 0x64]
... и так далее
```

**Padding (дополнение):**
Если последний блок меньше требуемого размера, он дополняется:
```
Последний блок: "age" (3 байта)
После padding: "age" + [0x01] (4 байта)
```

**Код:**
```c
// Вычисление количества блоков
int num_blocks = (text_len + block_size - 1) / block_size;

// Применение padding по стандарту PKCS7
int padding_len = block_size - (text_len % block_size);
if (padding_len == 0) padding_len = block_size;
for (int i = 0; i < padding_len; i++) {
    padded_text[text_len + i] = (uint8_t)padding_len;
}
```

### 2.4. ШАГ 3: ОБРАБОТКА КАЖДОГО БЛОКА

**Для каждого блока выполняется цикл из 256 итераций (по числу бит ключа).**

#### 2.4.1. Загрузка блока в куб

**Что происходит:**
Байты блока загружаются в 3D структуру куба.

**Пример для блока 4 байта (куб 2×2×2):**
```
Блок: [b₀, b₁, b₂, b₃]

Куб:
     b₂ --- b₃
     /|     /|
    / |    / |
   b₀ --- b₁ |
   |  b₆ -|- b₇
   | /    | /
   |/     |/
   b₄ --- b₅

Где b₄-b₇ = 0 (заполнение для куба 2×2×2, но используем только 4 байта)
```

**Код:**
```c
uint8_t cube[MAX_BLOCK_SIZE];
memcpy(cube, &blocks[block_idx * block_size], block_size);
```

#### 2.4.2. Итерация по битам ключа

**Для каждого бита ключа i (от 0 до 255):**

##### Шаг 3.1: Извлечение бита ключа

**Что происходит:**
Извлекается i-й бит из ключа.

**Код:**
```c
int get_key_bit(const uint8_t *key, int bit_index) {
    int byte_index = bit_index / 8;
    int bit_in_byte = bit_index % 8;
    return (key[byte_index] >> (7 - bit_in_byte)) & 1;
}

// Использование:
int key_bit = get_key_bit(cipher->key, i);
```

**Пример:**
```
Ключ: [0xA5, 0x3C, ...] = [10100101, 00111100, ...]
         
Бит 0: 1 (старший бит первого байта)
Бит 1: 0
Бит 2: 1
Бит 3: 0
...
```

##### Шаг 3.2: Выбор операции

**Что происходит:**
На основе значения бита ключа выбирается операция из таблицы.

**Формула:**
```
operation_id = key_bit % 127
```

Поскольку key_bit может быть только 0 или 1:
- Если key_bit = 0, то operation_id = 0
- Если key_bit = 1, то operation_id = 1

**НО:** В улучшенных версиях используется более сложная схема:
```
operation_id = (i-й байт раундового ключа) % 127
```

**Код (оригинальная версия):**
```c
int operation_id = key_bit % 127;
```

##### Шаг 3.3: Применение операции

**Что происходит:**
К кубу применяется выбранная операция перестановки.

**Операция перестановки** — это перемещение байтов внутри куба.

**Пример операции (упрощенно):**
```
До операции:
cube[0] = 0x48
cube[1] = 0x65
cube[2] = 0x6C
cube[3] = 0x6C

Операция №5 (пример):
Переставить: позиция 0 ↔ позиция 2

После операции:
cube[0] = 0x6C  (было на позиции 2)
cube[1] = 0x65  (не изменилось)
cube[2] = 0x48  (было на позиции 0)
cube[3] = 0x6C  (не изменилось)
```

**Код:**
```c
void apply_operation(uint8_t *cube, int operation_id, int block_size) {
    // Применение заранее определенной перестановки
    uint8_t temp[MAX_BLOCK_SIZE];
    
    // Копирование с перестановкой
    for (int j = 0; j < block_size; j++) {
        temp[j] = cube[permutation_table[operation_id][j]];
    }
    
    // Копирование результата обратно
    memcpy(cube, temp, block_size);
}
```

##### Шаг 3.4: Циклический побитовый сдвиг

**Что происходит:**
Каждый байт куба циклически сдвигается на d бит (где d = размерность куба).

**Циклический сдвиг байта:**
```
Байт: 10100101
Сдвиг влево на 2 бита:
  10010110 (биты 1 и 0 переместились вправо)
```

**Формула:**
```
shifted_byte = ((byte << d) | (byte >> (8 - d))) & 0xFF
```

**Пример для d=2:**
```
Исходный байт: 0xA5 = 10100101
Сдвиг на 2:    0x96 = 10010110
```

**Код:**
```c
void cyclic_bitwise_shift(uint8_t *cube, int block_size, int d) {
    for (int j = 0; j < block_size; j++) {
        uint8_t byte = cube[j];
        cube[j] = ((byte << d) | (byte >> (8 - d))) & 0xFF;
    }
}
```

##### Шаг 3.5: Повторение для всех бит ключа

**Цикл выполняется 256 раз** (для 256-битного ключа):
```c
for (int i = 0; i < key_bits; i++) {  // key_bits = 256
    // 1. Извлечь бит ключа
    int key_bit = get_key_bit(cipher->key, i);
    
    // 2. Выбрать операцию
    int operation_id = key_bit % 127;
    
    // 3. Применить операцию
    apply_operation(cube, operation_id, block_size);
    
    // 4. Циклический сдвиг
    cyclic_bitwise_shift(cube, block_size, d_bits);
}
```

### 2.5. ШАГ 4: ИЗВЛЕЧЕНИЕ РЕЗУЛЬТАТА

**Что происходит:**
После всех итераций зашифрованный блок извлекается из куба.

**Код:**
```c
memcpy(&ciphertext[block_idx * block_size], cube, block_size);
```

### 2.6. ШАГ 5: ДЕШИФРОВАНИЕ

**Дешифрование — это обратный процесс:**

1. **Обработка бит ключа в обратном порядке** (от 255 до 0)
2. **Обратный циклический сдвиг** (сдвиг вправо вместо влево)
3. **Обратная операция** (используется обратная перестановка)

**Код:**
```c
// Обратная обработка
for (int i = key_bits - 1; i >= 0; i--) {  // В обратном порядке
    // 1. Обратный циклический сдвиг
    cyclic_bitwise_shift_inverse(cube, block_size, d_bits);
    
    // 2. Выбрать ту же операцию
    int key_bit = get_key_bit(cipher->key, i);
    int operation_id = key_bit % 127;
    
    // 3. Применить ОБРАТНУЮ операцию
    apply_operation_inverse(cube, operation_id, block_size);
}
```

### 2.7. СЛОЖНОСТЬ И ПРОИЗВОДИТЕЛЬНОСТЬ

**Временная сложность:** O(n × k)
- n = количество блоков
- k = количество бит ключа (256)

**Для 1 МБ данных:**
- Блоков (4 байта): 262,144
- Итераций на блок: 256
- Всего операций: 67,108,864

**Время выполнения:** ~100 секунд для 1 МБ

---

## 3. УЛУЧШЕННЫЙ АЛГОРИТМ - ПОДРОБНЫЕ ШАГИ

### Файлы: wbc1_parallel_new.c, wbc1_parallel_cached_new.c

### 3.1. КЛЮЧЕВЫЕ ОТЛИЧИЯ ОТ ОРИГИНАЛА

1. **Раундовая структура** вместо побитовой обработки
2. **S-box подстановка** для нелинейности
3. **Диффузия** для перемешивания
4. **Фиксированное количество раундов** (16 вместо 256 итераций)

### 3.2. ОБЩАЯ СХЕМА

```
Входные данные → Разбиение на блоки → Инициализация:
                                         ├─ Генерация S-box
                                         └─ Генерация раундовых ключей
                  
                 → Для каждого блока:
                     └─ Для каждого раунда (1..16):
                          ├─ 32 операции перестановки
                          ├─ Циклические сдвиги
                          ├─ XOR с раундовым ключом
                          ├─ S-box подстановка
                          ├─ Диффузия (2 слоя)
                          └─ Следующий раунд
                  
                 → Объединение блоков → Зашифрованные данные
```

### 3.3. ШАГ 1: ИНИЦИАЛИЗАЦИЯ

#### 3.3.1. Генерация S-box

**Что такое S-box?**
S-box (substitution box) — это таблица подстановки, которая заменяет каждое значение байта (0-255) на другое значение.

**Зачем нужен?**
- Обеспечивает **нелинейность** (защита от линейного криптоанализа)
- Делает зависимость между входом и выходом сложной

**Как генерируется:**
1. Используется ключ как seed
2. Применяется SHA-256 для генерации псевдослучайных чисел
3. Используется MT19937 (Mersenne Twister) для генерации перестановки
4. Создается биекция: каждое значение 0-255 отображается в уникальное значение

**Код:**
```c
void generate_sbox(uint8_t sbox[256], uint8_t inv_sbox[256], 
                   const uint8_t *key, int key_len) {
    // 1. Хешируем ключ
    uint8_t hash[32];
    SHA256(key, key_len, hash);
    
    // 2. Используем хеш как seed для MT19937
    uint32_t seed = 0;
    for (int i = 0; i < 4; i++) {
        seed = (seed << 8) | hash[i];
    }
    
    // 3. Инициализируем генератор
    init_genrand(seed);
    
    // 4. Создаем начальную перестановку
    for (int i = 0; i < 256; i++) {
        sbox[i] = i;
    }
    
    // 5. Перемешиваем методом Фишера-Йейтса
    for (int i = 255; i > 0; i--) {
        int j = genrand_int32() % (i + 1);
        // Меняем местами sbox[i] и sbox[j]
        uint8_t temp = sbox[i];
        sbox[i] = sbox[j];
        sbox[j] = temp;
    }
    
    // 6. Создаем обратную таблицу
    for (int i = 0; i < 256; i++) {
        inv_sbox[sbox[i]] = i;
    }
}
```

**Пример результата:**
```
sbox[0] = 214
sbox[1] = 97
sbox[2] = 142
...
sbox[255] = 31

Это означает:
- Байт со значением 0 будет заменен на 214
- Байт со значением 1 будет заменен на 97
- И так далее
```

#### 3.3.2. Генерация раундовых ключей

**Что такое раундовый ключ?**
Для каждого раунда создается свой ключ размером с блок (16 байт).

**Как генерируется:**
```c
void generate_round_key(uint8_t *round_key, const uint8_t *master_key, 
                        int key_len, int round_number) {
    // 1. Создаем буфер: мастер-ключ + номер раунда
    uint8_t buffer[key_len + 4];
    memcpy(buffer, master_key, key_len);
    
    // 2. Добавляем номер раунда в big-endian
    buffer[key_len] = (round_number >> 24) & 0xFF;
    buffer[key_len + 1] = (round_number >> 16) & 0xFF;
    buffer[key_len + 2] = (round_number >> 8) & 0xFF;
    buffer[key_len + 3] = round_number & 0xFF;
    
    // 3. Хешируем SHA-256
    uint8_t hash[32];
    SHA256(buffer, key_len + 4, hash);
    
    // 4. Берем первые 16 байт как раундовый ключ
    memcpy(round_key, hash, 16);
}
```

**Пример:**
```
Мастер-ключ: [K₀, K₁, ..., K₃₁] (32 байта)
Раунд 1: RK₁ = SHA256(K || 0x00000001)[0..15]
Раунд 2: RK₂ = SHA256(K || 0x00000002)[0..15]
...
Раунд 16: RK₁₆ = SHA256(K || 0x00000010)[0..15]
```

### 3.4. ШАГ 2: ОБРАБОТКА БЛОКА (ОДИН РАУНД)

**Для каждого раунда r (от 1 до 16):**

#### 3.4.1. Применение 32 операций перестановки

**Что происходит:**
Последовательно применяются 32 операции, выбранные на основе раундового ключа.

**Код:**
```c
// Для каждой операции в раунде (32 операции)
for (int j = 0; j < 32; j++) {
    // 1. Выбираем операцию из раундового ключа
    int operation_id = round_key[j % 16] % 127;
    
    // 2. Применяем операцию
    apply_operation(cube, operation_id, block_size);
    
    // 3. Циклический сдвиг
    cyclic_bitwise_shift(cube, block_size, d_bits);
}
```

**Детально:**
```
Раундовый ключ RK₁ = [rk₀, rk₁, ..., rk₁₅]

Операция 0:  op₀ = rk₀ % 127
Операция 1:  op₁ = rk₁ % 127
...
Операция 15: op₁₅ = rk₁₅ % 127
Операция 16: op₁₆ = rk₀ % 127  (повторяем)
...
Операция 31: op₃₁ = rk₁₅ % 127
```

#### 3.4.2. XOR с раундовым ключом

**Что происходит:**
Каждый байт блока XOR-ится с соответствующим байтом раундового ключа.

**Код:**
```c
for (int j = 0; j < block_size; j++) {
    cube[j] ^= round_key[j % 16];
}
```

**Пример:**
```
Блок:        [0x48, 0x65, 0x6C, 0x6C, ...]
Раунд. ключ: [0xA5, 0x3C, 0xF2, 0x81, ...]
Результат:   [0xED, 0x59, 0x9E, 0xED, ...]
              ↑     ↑     ↑     ↑
           48⊕A5  65⊕3C  6C⊕F2  6C⊕81
```

#### 3.4.3. S-box подстановка

**Что происходит:**
Каждый байт блока заменяется через S-box таблицу.

**Код:**
```c
for (int j = 0; j < block_size; j++) {
    cube[j] = sbox[cube[j]];
}
```

**Пример:**
```
До S-box:    [0xED, 0x59, 0x9E, 0xED]
После S-box: [0x72, 0xA1, 0x3F, 0x72]
              ↑     ↑     ↑     ↑
          sbox[ED] sbox[59] sbox[9E] sbox[ED]
```

#### 3.4.4. Диффузия (первый слой)

**Что такое диффузия?**
Диффузия — это перемешивание данных таким образом, чтобы изменение одного бита входа влияло на много бит выхода.

**Метод: Cumulative XOR**

**Код:**
```c
void diffusion_layer(uint8_t *block, int block_size) {
    uint8_t temp[MAX_BLOCK_SIZE];
    temp[0] = block[0];
    
    // Каждый байт = предыдущий XOR текущий
    for (int i = 1; i < block_size; i++) {
        temp[i] = temp[i-1] ^ block[i];
    }
    
    memcpy(block, temp, block_size);
}
```

**Пример:**
```
До диффузии:  [A, B, C, D]
После:        [A, A⊕B, A⊕B⊕C, A⊕B⊕C⊕D]

Конкретно:
[0x72, 0xA1, 0x3F, 0x72]
[0x72, 0xD3, 0xEC, 0x9E]
  ↑     ↑     ↑     ↑
  A    A⊕B   A⊕B⊕C  A⊕B⊕C⊕D
```

#### 3.4.5. Диффузия (второй слой)

**Второй слой применяется в обратном направлении:**

**Код:**
```c
void diffusion_layer_reverse(uint8_t *block, int block_size) {
    uint8_t temp[MAX_BLOCK_SIZE];
    temp[block_size - 1] = block[block_size - 1];
    
    // Справа налево
    for (int i = block_size - 2; i >= 0; i--) {
        temp[i] = temp[i+1] ^ block[i];
    }
    
    memcpy(block, temp, block_size);
}
```

**Эффект:**
Теперь изменение любого бита влияет на все остальные биты блока.

### 3.5. ШАГ 3: ПОВТОРЕНИЕ РАУНДОВ

Все описанные шаги (3.4.1 - 3.4.5) повторяются для всех 16 раундов.

**Код (упрощенно):**
```c
// Для каждого раунда
for (int round = 1; round <= 16; round++) {
    // 1. Генерируем раундовый ключ
    uint8_t round_key[16];
    generate_round_key(round_key, master_key, key_len, round);
    
    // 2. Применяем 32 операции
    for (int j = 0; j < 32; j++) {
        int op_id = round_key[j % 16] % 127;
        apply_operation(cube, op_id, block_size);
        cyclic_bitwise_shift(cube, block_size, d_bits);
    }
    
    // 3. XOR с раундовым ключом
    for (int j = 0; j < block_size; j++) {
        cube[j] ^= round_key[j % 16];
    }
    
    // 4. S-box подстановка
    for (int j = 0; j < block_size; j++) {
        cube[j] = sbox[cube[j]];
    }
    
    // 5. Диффузия (2 слоя)
    diffusion_layer(cube, block_size);
    diffusion_layer_reverse(cube, block_size);
}
```

### 3.6. ШАГ 4: ДЕШИФРОВАНИЕ

**Дешифрование выполняется в обратном порядке:**

1. **Раунды в обратном порядке** (от 16 до 1)
2. **Обратная диффузия** (сначала обратная обратной, потом обратная прямой)
3. **Обратная S-box** (используется inv_sbox)
4. **XOR с раундовым ключом** (XOR обратим сам себе)
5. **Обратные операции в обратном порядке** (31..0)

**Код:**
```c
// Раунды в обратном порядке
for (int round = 16; round >= 1; round--) {
    // 1. Генерируем тот же раундовый ключ
    uint8_t round_key[16];
    generate_round_key(round_key, master_key, key_len, round);
    
    // 2. Обратная диффузия (в обратном порядке)
    diffusion_layer_reverse_inverse(cube, block_size);
    diffusion_layer_inverse(cube, block_size);
    
    // 3. Обратная S-box
    for (int j = 0; j < block_size; j++) {
        cube[j] = inv_sbox[cube[j]];
    }
    
    // 4. XOR с раундовым ключом (то же самое)
    for (int j = 0; j < block_size; j++) {
        cube[j] ^= round_key[j % 16];
    }
    
    // 5. Обратные операции (в обратном порядке)
    for (int j = 31; j >= 0; j--) {
        int op_id = round_key[j % 16] % 127;
        cyclic_bitwise_shift_inverse(cube, block_size, d_bits);
        apply_operation_inverse(cube, op_id, block_size);
    }
}
```

### 3.7. СЛОЖНОСТЬ И ПРОИЗВОДИТЕЛЬНОСТЬ

**Временная сложность:** O(n)
- n = количество блоков
- Фиксированное количество раундов (16)
- Фиксированное количество операций на раунд (32)

**Для 1 МБ данных:**
- Блоков: 65,536 (для 16-байтовых блоков)
- Раундов на блок: 16
- Операций на раунд: 32
- Всего операций: 33,554,432

**Время выполнения:** ~0.4 секунды для 1 МБ

**Сравнение с оригиналом:**
- Оригинал: O(n × k) = O(n × 256)
- Улучшенный: O(n × 16 × 32) = O(n × 512)
- НО: операции выполняются быстрее благодаря предсказуемости
- **Реальное ускорение: ~250×**

---

## 4. ПАРАМЕТРИЧЕСКИЙ АЛГОРИТМ - ПОДРОБНЫЕ ШАГИ

### Файл: wbc1_parallel_gen_cached.c

### 4.1. КЛЮЧЕВОЕ ОТЛИЧИЕ

**В параметрической версии операции не фиксированы, а генерируются динамически на основе ключа!**

Это означает:
- Нет таблицы из 127 операций
- Каждая операция вычисляется через PRF (Pseudorandom Function)
- Бесконечное пространство возможных операций
- Максимальная криптографическая стойкость

### 4.2. ШАГ 1: ГЕНЕРАЦИЯ ОПЕРАЦИИ ЧЕРЕЗ PRF

**PRF (Pseudorandom Function):**
Функция, которая на основе ключа и входа генерирует псевдослучайный выход.

**Используется:** SHA-256

**Код:**
```c
void generate_permutation_from_key(uint8_t *perm, const uint8_t *key, 
                                   int key_len, int operation_id, 
                                   int block_size) {
    // 1. Создаем входные данные: ключ || operation_id
    uint8_t input[key_len + 4];
    memcpy(input, key, key_len);
    input[key_len] = (operation_id >> 24) & 0xFF;
    input[key_len + 1] = (operation_id >> 16) & 0xFF;
    input[key_len + 2] = (operation_id >> 8) & 0xFF;
    input[key_len + 3] = operation_id & 0xFF;
    
    // 2. Хешируем
    uint8_t hash[32];
    SHA256(input, key_len + 4, hash);
    
    // 3. Используем хеш как seed для генерации перестановки
    uint32_t seed = 0;
    for (int i = 0; i < 4; i++) {
        seed = (seed << 8) | hash[i];
    }
    init_genrand(seed);
    
    // 4. Генерируем перестановку методом Фишера-Йейтса
    for (int i = 0; i < block_size; i++) {
        perm[i] = i;
    }
    
    for (int i = block_size - 1; i > 0; i--) {
        int j = genrand_int32() % (i + 1);
        uint8_t temp = perm[i];
        perm[i] = perm[j];
        perm[j] = temp;
    }
}
```

**Пример:**
```
Ключ: K = [0xA5, 0x3C, ...]
Operation_id: 5

Генерация:
hash = SHA256(K || 0x00000005)
seed = первые 4 байта hash
perm = Fisher-Yates(seed, block_size)

Результат (пример):
perm = [3, 0, 5, 7, 1, 2, 4, 6, ...]
```

### 4.3. ШАГ 2: КЕШИРОВАНИЕ ОПЕРАЦИЙ

**Проблема:** Генерация операций через PRF медленная.

**Решение:** Кешируем результаты!

**Структура кеша:**
```c
typedef struct {
    uint8_t forward_perm[MAX_BLOCK_SIZE];   // Прямая перестановка
    uint8_t inverse_perm[MAX_BLOCK_SIZE];   // Обратная перестановка
    int cached;                              // Флаг: закеширована ли
} OperationCache;

OperationCache cache[MAX_OPERATIONS];  // Кеш для всех операций
```

**Процесс:**
1. При первом обращении к операции — генерируем и кешируем
2. При повторных обращениях — используем закешированную

**Код:**
```c
void get_operation(uint8_t *perm, int operation_id, 
                   const uint8_t *key, int key_len, int block_size) {
    // Проверяем кеш
    if (cache[operation_id].cached) {
        // Используем закешированное
        memcpy(perm, cache[operation_id].forward_perm, block_size);
        return;
    }
    
    // Генерируем новую операцию
    generate_permutation_from_key(perm, key, key_len, 
                                  operation_id, block_size);
    
    // Кешируем
    memcpy(cache[operation_id].forward_perm, perm, block_size);
    
    // Вычисляем обратную
    for (int i = 0; i < block_size; i++) {
        cache[operation_id].inverse_perm[perm[i]] = i;
    }
    
    cache[operation_id].cached = 1;
}
```

### 4.4. ШАГ 3: ШИФРОВАНИЕ

**Процесс аналогичен улучшенному алгоритму**, но операции генерируются динамически:

```c
for (int round = 1; round <= 16; round++) {
    // Генерируем раундовый ключ
    generate_round_key(round_key, master_key, key_len, round);
    
    // Применяем операции
    for (int j = 0; j < 32; j++) {
        // Вычисляем operation_id
        int op_id = round_key[j % 16];  // Не % 127!
        
        // Получаем операцию (из кеша или генерируем)
        uint8_t perm[MAX_BLOCK_SIZE];
        get_operation(perm, op_id, master_key, key_len, block_size);
        
        // Применяем
        apply_permutation(cube, perm, block_size);
        cyclic_bitwise_shift(cube, block_size, d_bits);
    }
    
    // Остальные шаги как в улучшенном алгоритме
    // ...
}
```

### 4.5. ПРЕИМУЩЕСТВА

1. **Бесконечное пространство операций**
   - Не ограничены 127 операциями
   - Можем использовать 0..255 (или больше)

2. **Ключезависимая безопасность**
   - Операции зависят от ключа
   - Разные ключи → разные операции

3. **Максимальная стойкость**
   - Невозможно заранее знать операции без ключа
   - Защита от атак с известной структурой

---

## 5. КОНКРЕТНЫЙ ПРИМЕР ШИФРОВАНИЯ

### 5.1. ИСХОДНЫЕ ДАННЫЕ

```
Текст: "Hello"
Ключ: 0xA53CF2810D9B4E7C... (32 байта)
Размер блока: 4 байта (32 бита)
Алгоритм: Оригинальный
```

### 5.2. ШАГ ЗА ШАГОМ

#### Шаг 1: Подготовка блока

```
Текст: "Hello" = [0x48, 0x65, 0x6C, 0x6C, 0x6F]
                  H     e     l     l     o

Разбиение на блоки по 4 байта:
Блок 0: [0x48, 0x65, 0x6C, 0x6C] = "Hell"
Блок 1: [0x6F, 0x01, 0x01, 0x01] = "o" + padding
```

#### Шаг 2: Обработка блока 0

**Загрузка в куб (2×2×2):**
```
cube[0] = 0x48  (H)
cube[1] = 0x65  (e)
cube[2] = 0x6C  (l)
cube[3] = 0x6C  (l)
```

**Итерация 0 (бит ключа 0):**

```
1. Извлечь бит ключа:
   key_byte_0 = 0xA5 = 10100101
   key_bit_0 = 1 (старший бит)

2. Выбрать операцию:
   operation_id = 1 % 127 = 1

3. Применить операцию №1:
   Допустим, операция №1 это: [1, 0, 3, 2]
   (переставить: 0↔1, 2↔3)
   
   До:  [0x48, 0x65, 0x6C, 0x6C]
   После: [0x65, 0x48, 0x6C, 0x6C]

4. Циклический сдвиг (d=2 для куба 2×2×2):
   0x65 → 0x96  (01100101 → 10010110)
   0x48 → 0x21  (01001000 → 00100001)
   0x6C → 0xB1  (01101100 → 10110001)
   0x6C → 0xB1  (01101100 → 10110001)
   
   Результат: [0x96, 0x21, 0xB1, 0xB1]
```

**Итерация 1 (бит ключа 1):**

```
1. Извлечь бит ключа:
   key_bit_1 = 0 (второй бит байта 0xA5)

2. Выбрать операцию:
   operation_id = 0 % 127 = 0

3. Применить операцию №0:
   Допустим, операция №0 — идентичность (не меняет)
   
   До:  [0x96, 0x21, 0xB1, 0xB1]
   После: [0x96, 0x21, 0xB1, 0xB1]

4. Циклический сдвиг:
   0x96 → 0x5A  (10010110 → 01011001)
   0x21 → 0x84  (00100001 → 10000100)
   0xB1 → 0xC6  (10110001 → 11000110)
   0xB1 → 0xC6  (10110001 → 11000110)
   
   Результат: [0x5A, 0x84, 0xC6, 0xC6]
```

**... (продолжается для всех 256 бит) ...**

**Финальный результат после 256 итераций:**
```
Зашифрованный блок 0: [0xE3, 0x8D, 0x2F, 0xA1]
```

#### Шаг 3: Обработка блока 1

Аналогично блоку 0.

#### Шаг 4: Объединение

```
Результат шифрования:
Блок 0: [0xE3, 0x8D, 0x2F, 0xA1]
Блок 1: [0x7B, 0x45, 0x9C, 0xD2]

Ciphertext: [0xE3, 0x8D, 0x2F, 0xA1, 0x7B, 0x45, 0x9C, 0xD2]
```

### 5.3. ДЕШИФРОВАНИЕ

**Обратный процесс:**

```
Ciphertext: [0xE3, 0x8D, 0x2F, 0xA1]

Итерация 255 (последний бит ключа):
1. Обратный циклический сдвиг
2. Применить обратную операцию

Итерация 254:
1. Обратный циклический сдвиг
2. Применить обратную операцию

... (продолжается до итерации 0) ...

Результат: [0x48, 0x65, 0x6C, 0x6C] = "Hell" ✓
```

---

## 6. СТРУКТУРЫ ДАННЫХ И РЕАЛИЗАЦИЯ

### 6.1. ОСНОВНЫЕ СТРУКТУРЫ

#### 6.1.1. Структура шифра (оригинальная версия)

```c
typedef struct {
    uint8_t key[MAX_KEY_SIZE];      // Ключ шифрования
    int key_len;                     // Длина ключа в байтах
    int block_size_bits;             // Размер блока в битах
    int block_size;                  // Размер блока в байтах
    int d1, d2, d3;                  // Размеры куба
    int d_bits;                      // Число бит для сдвига
} WBC1OriginalCipher;
```

#### 6.1.2. Структура шифра (улучшенная версия)

```c
typedef struct {
    uint8_t key[MAX_KEY_SIZE];      // Ключ
    int key_len;                     // Длина ключа
    int block_size;                  // Размер блока
    uint8_t sbox[256];               // S-box таблица
    uint8_t inv_sbox[256];           // Обратная S-box
    int num_rounds;                  // Количество раундов (16)
    int operations_per_round;        // Операций на раунд (32)
    int mode;                        // Режим (0 или 1)
} WBC1EnhancedCipher;
```

#### 6.1.3. Кеш операций (кешированные версии)

```c
typedef struct {
    uint8_t forward_result[MAX_BLOCK_SIZE];   // Результат прямой операции
    uint8_t inverse_result[MAX_BLOCK_SIZE];   // Результат обратной операции
} OperationCache;

typedef struct {
    OperationCache ops[127];         // Кеш для всех 127 операций
    int initialized;                 // Флаг инициализации
} CipherCache;
```

### 6.2. КЛЮЧЕВЫЕ ФУНКЦИИ

#### 6.2.1. Оригинальный алгоритм

```c
// Инициализация
void wbc1_original_init(WBC1OriginalCipher *cipher, 
                        const uint8_t *key, int key_len, 
                        int block_size_bits);

// Шифрование блока
void wbc1_original_encrypt_block(WBC1OriginalCipher *cipher,
                                 const uint8_t *plaintext,
                                 uint8_t *ciphertext);

// Дешифрование блока
void wbc1_original_decrypt_block(WBC1OriginalCipher *cipher,
                                 const uint8_t *ciphertext,
                                 uint8_t *plaintext);

// Получить бит ключа
int get_key_bit(const uint8_t *key, int bit_index);

// Применить операцию
void apply_operation(uint8_t *cube, int operation_id, int block_size);

// Циклический побитовый сдвиг
void cyclic_bitwise_shift(uint8_t *cube, int block_size, int d_bits);
```

#### 6.2.2. Улучшенный алгоритм

```c
// Инициализация
void wbc1_enhanced_init(WBC1EnhancedCipher *cipher,
                       const uint8_t *key, int key_len);

// Генерация S-box
void generate_sbox(uint8_t sbox[256], uint8_t inv_sbox[256],
                  const uint8_t *key, int key_len);

// Генерация раундового ключа
void generate_round_key(uint8_t *round_key,
                       const uint8_t *master_key, int key_len,
                       int round_number);

// Шифрование блока
void wbc1_enhanced_encrypt_block(WBC1EnhancedCipher *cipher,
                                const uint8_t *plaintext,
                                uint8_t *ciphertext);

// Дешифрование блока
void wbc1_enhanced_decrypt_block(WBC1EnhancedCipher *cipher,
                                const uint8_t *ciphertext,
                                uint8_t *plaintext);

// Диффузия
void diffusion_layer(uint8_t *block, int block_size);
void diffusion_layer_reverse(uint8_t *block, int block_size);
```

### 6.3. MPI ПАРАЛЛЕЛИЗАЦИЯ

**MPI (Message Passing Interface)** используется для распараллеливания обработки блоков.

#### 6.3.1. Схема распределения

```
Master процесс (rank 0):
├─ Чтение входных данных
├─ Разбиение на блоки
└─ Распределение блоков между процессами (MPI_Scatter)

Worker процессы (rank 1, 2, ...):
├─ Получение блоков
├─ Шифрование/дешифрование своих блоков
└─ Отправка результатов обратно

Master процесс:
├─ Сбор результатов (MPI_Gather)
└─ Объединение и вывод
```

#### 6.3.2. Код распараллеливания

```c
// Получить информацию о процессах
int rank, size;
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
MPI_Comm_size(MPI_COMM_WORLD, &size);

// Вычислить количество блоков на процесс
int blocks_per_process = num_blocks / size;
int remainder = num_blocks % size;

// Распределить блоки
if (rank == 0) {
    // Master: отправляет блоки
    for (int i = 1; i < size; i++) {
        int start = i * blocks_per_process;
        int count = blocks_per_process;
        if (i == size - 1) count += remainder;
        
        MPI_Send(&plaintext[start * block_size], 
                 count * block_size, MPI_BYTE, i, 0, 
                 MPI_COMM_WORLD);
    }
    
    // Master тоже обрабатывает свои блоки
    process_blocks(&plaintext[0], blocks_per_process);
} else {
    // Workers: получают и обрабатывают
    int count = blocks_per_process;
    if (rank == size - 1) count += remainder;
    
    uint8_t *buffer = malloc(count * block_size);
    MPI_Recv(buffer, count * block_size, MPI_BYTE, 0, 0,
             MPI_COMM_WORLD, MPI_STATUS_IGNORE);
    
    process_blocks(buffer, count);
    
    // Отправляем результаты обратно
    MPI_Send(buffer, count * block_size, MPI_BYTE, 0, 0,
             MPI_COMM_WORLD);
    
    free(buffer);
}

// Master собирает результаты
if (rank == 0) {
    for (int i = 1; i < size; i++) {
        int start = i * blocks_per_process;
        int count = blocks_per_process;
        if (i == size - 1) count += remainder;
        
        MPI_Recv(&ciphertext[start * block_size],
                 count * block_size, MPI_BYTE, i, 0,
                 MPI_COMM_WORLD, MPI_STATUS_IGNORE);
    }
}
```

---

## 7. ФАЙЛЫ ПРОЕКТА И ИХ НАЗНАЧЕНИЕ

### 7.1. ОСНОВНЫЕ РЕАЛИЗАЦИИ (C)

| Файл | Строк | Описание |
|------|-------|----------|
| **wbc1_original_parallel.c** | ~1000 | Оригинальная версия с побитовой обработкой ключа |
| **wbc1_original_cached.c** | ~1100 | Оригинальная + кеширование операций и сдвигов |
| **wbc1_parallel_new.c** | ~1800 | Улучшенная версия: раунды, S-box, диффузия |
| **wbc1_parallel_cached_new.c** | ~1750 | Улучшенная + кеширование |
| **wbc1_parallel_cached_opti.c** | ~1810 | Максимально оптимизированная с кешем |
| **wbc1_parallel_gen_cached.c** | ~1880 | Параметрическая: генерация операций через PRF |
| **wbc1_parallel_minimal.c** | ~1665 | Упрощенная версия для понимания |
| **wbc1_parallel.c** | ~1620 | Базовая реализация |
| **wbc1_parallel_cached.c** | ~1550 | Базовая + кеширование |

### 7.2. РЕАЛИЗАЦИИ НА PYTHON

| Файл | Описание |
|------|----------|
| **wbc1_parallel.py** | Python реализация базовой версии |
| **wbc1_parallel_cached.py** | Python версия с кешированием |
| **example_parallel.py** | Примеры использования |
| **interactive_cipher.py** | Интерактивный интерфейс |
| **test_wbc1.py** | Тесты |
| **benchmark.py** | Бенчмарки производительности |

### 7.3. ДОКУМЕНТАЦИЯ

| Файл | Размер | Описание |
|------|--------|----------|
| **WBC1_MATHEMATICAL_DESCRIPTION.md** | 36 KB | Полное математическое описание |
| **WBC1_ORIGINAL_README.md** | 17 KB | Документация оригинальной версии |
| **WBC1_ENHANCED_README.md** | 6.5 KB | Документация улучшенной версии |
| **WBC1_PARAMETRIC_README.md** | 14 KB | Документация параметрической версии |
| **WBC1_C_README.md** | 11 KB | Руководство по C реализации |
| **README.md** | 8.5 KB | Основное README |
| **USAGE.md** | 7 KB | Инструкции по использованию |
| **QUICKREF.md** | 3.2 KB | Быстрый справочник |

### 7.4. ФАЙЛЫ СБОРКИ И ТЕСТИРОВАНИЯ

| Файл | Описание |
|------|----------|
| **Makefile** | Сборка всех C версий |
| **requirements.txt** | Python зависимости |
| **check_requirements.sh** | Проверка зависимостей |
| **verify_original_tests.sh** | Тесты оригинальной версии |
| **verify_tests_simple.sh** | Простые тесты |
| **CHECK_FILE_STATUS.sh** | Проверка статуса файлов |

### 7.5. ТЕХНИЧЕСКИЕ ДОКУМЕНТЫ

| Файл | Описание |
|------|----------|
| **PERFORMANCE_FIX_SUMMARY.md** | Исправления производительности |
| **DECRYPTION_PADDING_FIX.md** | Исправление padding при дешифровании |
| **COMPILATION_ERRORS_FIXED.md** | Исправленные ошибки компиляции |
| **ORIGINAL_UPDATES_SUMMARY.md** | Обновления оригинальной версии |
| **DATA_SIZE_SELECTION_FEATURE.md** | Функция выбора размера данных |

---

## ЗАКЛЮЧЕНИЕ

### Ключевые моменты

1. **WBC1 — это семейство шифров**, основанных на концепции куба Рубика

2. **Три основных подхода:**
   - **Оригинальный**: Побитовая обработка ключа, простой, медленный
   - **Улучшенный**: Раундовая структура, S-box, диффузия, быстрый
   - **Параметрический**: Динамическая генерация операций, максимальная стойкость

3. **Производительность:**
   - Оригинальный: O(n × k) — медленно
   - Улучшенный: O(n) — в 256× быстрее
   - Кешированный: O(n) — в 10-100× быстрее некешированного

4. **Применение:**
   - Оригинальный — обучение, понимание алгоритма
   - Улучшенный — продакшн, общее использование
   - Параметрический — максимальная безопасность

5. **Реализации:**
   - 9 версий на C с разными оптимизациями
   - 2 версии на Python
   - MPI параллелизация для масштабируемости

### Рекомендации по выбору версии

```
Цель: Обучение → wbc1_original_parallel.c
Цель: Производительность → wbc1_parallel_cached_opti.c
Цель: Максимальная стойкость → wbc1_parallel_gen_cached.c
Цель: Понимание → wbc1_parallel_minimal.c
Язык: Python → wbc1_parallel_cached.py
```

### Дополнительные ресурсы

- **WBC1_MATHEMATICAL_DESCRIPTION.md** — для математических деталей
- **WBC1_C_README.md** — для подробностей реализации на C
- **USAGE.md** — для примеров использования
- **benchmark.py** — для сравнения производительности

---

**Документ создан:** 2026-02-06  
**Версия:** 1.0  
**Автор:** Анализ кода WBC1  
**Полное покрытие:** 9 реализаций, ~14,000 строк кода
